# 원시 타입과 객체 타입

## 원시 값

- 변경 불가능한 값
- 읽기 전용 값
- 변수에 할당시 변수에 실제 값이 저장
- 원시 값을 갖는 변수를 다른 변수에 할당시 원시 값이 복사되어 전달(값에 의한 전달)

⭐ 변수와 상수 variable, constant

- 변수 : 재할당으로 변수 값 변경(교체)할 수 있다
- 상수 : 단 한 번만 할당을 허용하므로 변수 값을 변경(교체)할 수 없다

<br>

### 불변성 immutability

- 데이터의 원본이 훼손되는 것을 막기 위한 것
- 변수 값의 변경을 위해 원시 값을 재할당 시, 새 메모리 공간을 확보하고 재할당한 값을 저장 후 변수가 참조하던 메모리 공간의 주소를 변경하는 것
- 재할당은 원시 값을 할당한 변수의 값을 변경하는 유일한 방법이다

```js
// 원시 값은 변경할 수 없다
const str = "string";
str[0] = "S";

console.log(str); // "string"

// 재할당으로 값 변경 가능
let hello = "Hello";
hello = "World";

console.log(hello); // "World"
```

⭐ 유사 배열 객체

- 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고, `length` 프로퍼티를 갖는 객체
- `for`문으로 순회할 수 있다
- 문자열은 유사 배열이므로 인덱스를 사용해 접근할 수 있다

<br>

### 값에 의한 전달

- 변수에 원시 값을 갖는 변수를 할당 시, 할당받은 변수에는 변수의 원시 값이 복사되어 전달되는 것
- 다른 메모리 공간에 별개의 값이 저장되는 것(변수에 값이 아닌 메모리 주소가 전달)
- 식별자는 메모리 주소를 기억하게 된다

▶️ 전달된 메모리 주소를 통해 메모리 공간에 접근 시 값을 참조할 수 있다
▶️ 한 변수에 원시 값을 갖는 변수를 할당하면, 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되므로 어느 한쪽에서 재할당을 통해 값을 변경해도 서로 간섭할 수 없다

```js
const score = 80;
const copy = score;

score = 100;

// 원본 값
console.log(score); // 100 
// 복사한 값
console.log(copy); // 80  
```

<br>
<br>

# 객체

- 변경 가능한 값
- 객체 값을 변수에 할당시 변수에 참조 값이 저장된다
- 객체 값을 가리키는 변수를 다른 변수에 할당 시 원본의 참조 값이 복사되어 전달(참조에 의한 전달)
- 참조 값은 생성된 객체가 저장된 메모리 공간의 주소이다
- 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다(프로퍼티 동적 추가, 갱신, 삭제)


⭐ 클래스 기반 객체지향 언어와 자바스크립트

- Java, C++같은 클래스 기반 객체지향 프로그래밍 언어는 사전에 정의된 클래스를 기반으로 객체가 생성되므로 프로퍼티와 메소드가 정해져있다(생성 후 삭제,추가 불가)
- 자바스크립트는 클래스 없이 객체를 생성할 수 있어 동적으로 프로퍼티와 메소드를 추가할 수 있다(객체의 생성, 접근 비용이 더 많이 소모)

```js
const person = {
  name: "won",
};

// 프로퍼티 값 갱신
person.name = "WON";

// 프로퍼티 값 동적 추가
person.address = "Seoul";

console.log(person); // { name: 'WON', address: 'Seoul' }
```

⭐ 자바스크립트 객체가 변경가능한 값인 이유는 메모리의 효율적 소비가 어렵고 성능이 나빠지는 것을 최소화 하기 위해서다

- 원시 값처럼 원본을 복사해 새 값을 생성 시 데이터가 명확하고 신뢰성이 확보된다
- 객체는 크기가 클 수 있고, 크기가 일정하지도 않고, 프로퍼티 값이 객체일 수도 있어서 복사 후 생성하는 비용이 많이 든다
- 객체를 복사해 생성하는 비용을 절약하여 성능을 향상시키기 위해 변경 가능한 값으로 설계된 것이다

▶️ 여러 개의 식별자가 하나의 객체를 공유하는 단점이 존재

<br>

```js
const person1 = {
  name: "won",
};

const person2 = {
  name: "won",
};

// 객체 리터럴은 평가될 때마다 객체를 생성, 두 변수가 가리키는 객체는 서로 다른 객체다
console.log(person1 === person2) // false

// 프로퍼티 값을 참조하는 것은 표현식이므로 같은 원시 값(won)으로 평가된다
console.log(person1.name === person2.name) // true
```


### 참조에 의한 전달(참조 할당, 참조 복사)

- 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달되는 것
- 다른 프로그래밍 언어의 참조에 의한 전달과 다르다
- 자바스크립트에는 포인터가 존재하지 않는다
- 얕은 복사

⭐ 값에 의한 전달과 참조에 의한 전달 모두 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다

▶️ 식별자가 기억하는 메모리 공간이 원시 값인지, 참조 값인지 구별할 뿐이다 

▶️ 자바스크립트는 값에 의한 전달만 존재한다

```js
const person = {
  name: "won",
};

// 참조 값 복사
// copy와 person이 동일한 객체 참조(해당 객체에 접근하는 통로를 2개로 만든 것)
const copy = person;
console.log(copy === person); // true

// copy를 통해 객체의 name 프로퍼티 변경
copy.name = "WON";

// person을 통해 객체의 address 프로퍼티 동적 생성
person.address = "Seoul";

console.log(person); // { name: 'WON', address: 'Seoul' }
console.log(copy); // { name: 'WON', address: 'Seoul' }
```


<br>

### 얕은 복사 / 깊은 복사 shallow copy, deep copy

#### 객체 얕은 복사

1. `Object.assign()` 사용
2. Spread Operator `...` 사용

- 깊이 1 까지만 복사
- 객체의 중첩된 객체는 참조 값을 복사한다
- 주소값만 복사 후 같은 메모리를 가리킨다

```js
let user = { name: "won" };

let obj1 = { isPerson: true };
let obj2 = { number: 123 };

// obj1과 obj2 프로퍼티 user로 복사
Object.assign(user, obj1, obj2);

console.log(user) // {name: 'won', isPerson: true, number: 123}

// 목표 객체에 동일한 프로퍼티가 있는 경우 값을 덮어씌운다
Object.assign(user, { name: "vvon" });

console.log(user) // {name: 'vvon', isPerson: true, number: 123}
```

#### 깊은 복사

1. Lodash 라이브러리 `clonedeep()` 사용

- 깊이 2 이상 전부 복사
- 객체 트리의 최말단 노드까지 복제
- 객체의 중첩된 객체까지 원시 값처럼 완전히 복사
- 데이터 자체를 복사(가장 많은 메모리 소모, 느린 처리 속도)
- 완전히 독립적인 메모리를 차지하게 된다

