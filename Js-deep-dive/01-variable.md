# 변수 variable

- 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 
- 그 메모리 공간을 식별하기 위해 붙인 이름 
- 값의 위치를 가리키는 상징적인 이름

```js
var result = 10 + 20;
```
▶️ result라는 변수에 10 + 20을 할당(대입)한 것

변수(result) : 메모리 공간에 저장된 값을 식별할 수 있는 고유 이름
변수값(30) : 변수에 저장된 값

## 할당과 참조

할당: `=`를 사용해 변수에 값을 저장하는 것(대입, 저장)  
참조: 변수에 저장된 값을 읽는 것

⭐ 저장된 값의 의미를 파악하기 위한 가독성도 고려해서 변수 이름을 지어야 한다(이름의 의도가 명확해야 코드를 이해하기 쉽고, 협업과 품질 향상에 도움을 준다)

# 식별자 identifier

- 어떤 값을 구별해서 식별할 수 있는 고유한 이름
- 클래스, 변수, 상수, 메소드 등에 붙이는 이름
- 선언을 통해 자바스크립트 엔진이 파악하게 된다

식별자는 값을 식별할 수 있어야 한다
식별자는 값이 아닌 __저장된 메모리 주소__ 를 기억한다 

식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다

즉, 식별자는 __메모리 주소에 붙인 이름__ 이다

- 변수, 함수, 클래스 등의 이름은 모두 식별자다

변수이름: 메모리 상에 존재하는 변수 값 식별  
함수이름: 메모리 상에 존재하는 함수(JS는 함수도 값으로 취급) 식별

- 식별자는 메모리 상에 존재하는 __어떤 값을 식별할 수 있는 이름__ 이다

# 변수 선언 Variable Declaration

- 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 과정
- 변수를 사용하려면 반드시 선언이 필요하다
- `var`, `let`, `const` 키워드를 사용해 변수를 선언한다

## `var`

- ES6 이전에 사용되었던 변수 선언 키워드
- 변수명 중복선언 가능, 값 재할당 가능
- 함수 스코프, 전역 스코프만 지원(=블록 밖에서 접근 가능)
- 의도치 않게 전역 변수가 선언되어 문제가 발생할 수 있다

## `let`, `const` 

- `var`의 단점을 보완하기위해 ES6부터 도입된 키워드 
- 블록 스코프, 함수 스코프, 전역 스코프 지원
- `let`: 변수명 중복선언 불가, 값 재할당 가능
- `const`: 변수명 중복선언 불가, 값 재할당 불가

## `var`, `let`, `const` 비교

|선언 키워드|변수명 중복선언|값 재할당|지원 스코프|
|----------------|-----------|---------|-----|
|`var`| O | O | 함수, 전역 |
|`let`| X | O | 블록, 함수, 전역 |
|`const`| X | X | 블록, 함수, 전역 |

## 변수 선언문(==변수 선언)

- 변수 이름을 등록하고 값을 저장할 메모리 공간을 확보하는 것
- 변수 선언 후 값은 아직 할당하지 않는다
- 메모리 공간이 확보되면 자바스크립트 엔진에 의해 암묵적으로 `undefined`가 할당된다

⭐ undefined : 자바스크립트에서 제공하는 원시타입 값. 자료형(==데이터 타입)

## 자바스크립트 엔진의 변수 선언 수행 과정

- 자바스크립트 엔진은 변수 선언을 2단계에 거쳐 수행한다

1. 선언 단계(변수 선언) : 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다
2. 초기화 단계(값 초기화) : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당해 초기화한다

`var`: 실행 컨텍스트의 실행 단계에서 선언단계, 초기화 단계 동시 진행. 런타임 과정에서 값 할당 진행

`let`,`const`: 실행 컨텍스트의 실행 단계에서 선언 단계만 진행. 런타임 과정에서 초기화 단계, 값 할당 진행 

```js
var person; 
```
1. 선언 단계를 통해 변수 이름을 person으로 등록
2. 초기화 단계를 통해 변수 person에 암묵적으로 undefined 할당

▶️ `var` 키워드로 선언한 변수 person은 값을 할당하지 않아도 기본적으로 undefined라는 값을 가지게 된다

```js
let person; 
```
1. 선언 단계를 통해 변수 이름을 person으로 등록
2. 런타임 시점에서 초기화 단계 진행, 암묵적으로 undefined 할당

```js
const person; 
```
1. 선언 단계를 통해 변수 이름을 person으로 등록
2. 런타임 시점에서 초기화 단계 진행되나, 초기화로 할당할 값이 없다는 의미의 오류 발생(SyntaxError: Missing initializer in const declaration)

▶️ `const` 키워드는 선언과 동시에 초기화 값을 필수로 요구한다

⭐ 실행 컨텍스트 Excute Context

- 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경
- 코드의 실행 결과를 실제로 관리하는 영역
- 모든 식별자는 실행 컨텍스트에 등록된다
- 모든 식별자(변수, 함수, 클래스 등)를 사용하려면 반드시 __선언__ 이 필요하다
- 자바스크립트 엔진은 등록된 실행 컨텐스트를 통해 __식별자__ 와 __스코프__ 를 관리한다

⭐ 참조 에러 Reference Error

- 선언하지 않은 식별자에 접근하면 발생
- 자바스크립트 엔진이 식별자를 이용해 값을 참조하려 했으나, 해당 식별자가 없을 때 발생

⭐ 일시적 사각지대(TDZ) Temporal Dead Zone

- 변수를 참조할 수 없는 구간
- 스코프의 시작 지점부터 초기화 시작 지점까지의 구간
- 선언 전에 사용하는 것을 허용하지 않기 위한 것
- 선언문이 존재하는 스코프 범위 안에서 변수에 영향을 준다
- `const`, `let`, `class`구문의 유효성 관리를 위한 것
- `var`, `function`, `import`는 영향을 받지 않는다(스코프에서 호이스팅 된다)


## 변수 선언의 실행 시점과 변수 호이스팅

### 변수 호이스팅(Hoisting)

- 변수 선언문보다 변수를 참조하는 코드가 앞에 있는 경우 발생
- 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 것
- 자바스크립트 고유의 특징

모든 선언문은 런타임 이전 단계에서 먼저 실행된다

`var`, `let`, `const`, `function`, `class`등의 키워드로 선언되는 모든 식별자는 호이스팅된다

```js
console.log(person); // undefined
var person; // 변수 선언문
```

- 자바스크립트는 __인터프리터__ 에 의해 한 줄씩 순차적으로 실행된다
- 코드 `console.log(person)`가 `var person`보다 위에 있어 ReferenceError가 발생할 것처럼 보이나 실제로는 undefind가 출력된다
- 변수 선언(선언 + 초기화 단계)이 런타임(소스코드가 한 줄씩 순차적으로 실행되는 것) 시점보다 먼저 실행되기 때문이다
- 즉, 소스코드를 한 줄씩 순차적으로 실행하기 전 __소스코드의 평가 과정__ 을 거치면서 실행을 위한 준비를 한다

### 소스 코드의 평가 과정

- 소스코드 실행 전에 모든 선언문(변수, 함수 선언문 등)을 소스코드에서 찾아내 먼저 실행하는 것
- 평가 과정이 끝나야 남은 소스코드를 한 줄씩 순차적으로 실행한다 
- 때문에 변수 선언이 어디에 있든 무조건 다른 코드보다 가장 먼저 실행하게 된다(선언의 위치 관계 없이 변수, 함수 등의 선언문을 참조 가능)
- 즉, 변수 선언과 값의 할당은 실행시점이 다르다(따라서 __선언__ 은 호이스팅이 되고, __할당__ 은 호이스팅 되지 않는다)

```js
var person = "Won"; 
```
▶️ 변수 선언과 값의 할당을 한 문장으로 표현(내부적 실행시점은 각자 다르다)

변수 선언 : 런타임 이전에 먼저 실행  
값의 할당 : 런타임에 실행

```js
console.log(person); // undefined

var person = "Won"; // 변수 선언 + 값 할당

console.log(person); // Won
```

## 상수와 변수, 값의 재할당 구조

### 상수 Constant

- 재할당이 불가능한 데이터 값
- 단 한번만 할당할 수 있는 변수(재할당이 금지된 변수)
- `const`로 선언해 상수를 표현한다

### 변수 Variable

- 재할당(변경)이 가능한 데이터 값
- 변수에 저장된 값은 다른 값으로 변경(재할당)할 수 있다
- `let`, `var`로 선언

### 값의 재할당

- 이미 값이 할당되어 있는 변수에 새로운 값을 다시 할당하는 것

```js
var person = "Won"; // 변수 선언 + 값 할당 
person = "YH"; // = 를 이용해 값 재할당 
```

▶️ 현재 변수에 저장된 값(Won)을 버리고 새로운 값(YH)을 저장

- `var`로 선언한 변수는 선언과 동시에 undefined로 초기화된다
- 즉, 변수에 처음 값을 할당하는 것도 사실 undefined인 값이 'Won'으로 재할당되는 것이다

- 값을 재할당 후, 이전 값인 undefined나 'Won'은 어떤 변수도 값으로 갖고 있지 않게 된다(연결된 식별자가 없다)
- 식별자가 연결되지 않은 값은 불필요한 값(불필요한 메모리)이라는 의미이므로, 가비지 콜렉터(Garbage collector)에 의해 메모리에서 자동 해제된다(해제 시점은 예측 불가)

# 식별자 네이밍 규칙

- 특수문자를 제외한 문자, 숫자, 언더스코어`_`, 달러 기호`$`를 포함 할 수 있다
- 숫자로 시작할 수 없다
- 예약어는 식별자로 사용할 수 없다

## 네이밍 컨벤션(Naming Convention)

- 하나 이상의 영단어로 구성된 식별자를 만들 때 가독성을 높이기 위해 규정한 이름 규칙

### 주요 네이밍 컨벤션

1. 카멜 케이스(camelCase)

2. 스네이크 케이스(snake_case)

3. 파스칼 케이스(PascalCase)

4. 케밥 케이스(kebab-case)

5. 헝가리안 케이스(typeHungarianCase) 
▶️ 변수타입(소문자) + 단어(파스칼 케이스)

- 일반적으로 자바스크립트에서는 변수나 함수 이름에는 카멜 케이스(camelCase), 생성자 함수, 클래스 이름에는 파스칼 케이스(PascalCase) 사용