
# 깃 플로우 전략 git flow strategy (models for work)

## git flow models

- 다수의 개발자들이 하나의 프로젝트 사이클을 안정적으로 돌리기 위해 사용하는 git 전략
- 깃 브랜치 전략이라고도 한다

### git-flow
- 5 종류의 브랜치(메인, 핫픽스, 디벨롭, 피처, 릴리스)를 가지고 개발하는 전략

장점
1. 주기적으로 배포하는 서비스에 적합
2. 각 단계가 명확히 구분됨

단점
1. 그만큼 복잡할 수 있다
2. 브랜치 구조가 복잡해질수록 관리가 어렵다
3. 일부 브랜치는 쓰이지 않거나 애매한 위치에 놓일 수 있다

#### 방식 
- 가장 중심이 되는 브랜치는 메인(Main)과 디벨롭(Develop)
- Hotfix, Feature, Release 브랜치는 병합 후 삭제
- main과 develop 두 종류의 브랜치는 병행으로 유지

1. 메인 브랜치(Main, Master branch) 
- 서비스 배포 가능한 프로젝트의 상태만 관리

2. 핫픽스 브랜치(Hotfix branch)
- 배포한 메인 버전에서 긴급한 수정사항이 있는 경우 분기
- 배포된 프로젝트의 버그 수정, 수치 조정 등 빠른 변경 후 main과 병합, 버전업
- 이후 변경된 사항들은 develop에도 병합해 다음 버전업에 적용되도록 처리

3. 디벨롭 브랜치(Develop branch)
- 다음에 배포할 것을 개발
- 잘 작동하고 있는 기존의 개발 코드를 유지하고 보존

4. 피처 브랜치(Feature branch)
- 기능을 개발하기 위한 브랜치
- develop으로부터 분기
- 기능 완성 후 프로젝트에 적용 시 develop과 병합, 원치 않으면 삭제
- 보통 개발자 저장소에만 있는 브랜치
- 원격 저장소(origin)에는 push를 하지 않는 편

5. 릴리스 브랜치(Release branch)
- develop에 이번 feature가 병합되었다면 hotfix와 함께 적용
- 버그 수정 등 전체적인 최종 단계를 점검, 마무리 후 main과 병합하고 버전업
- release의 기능점검 단계에서 발견/수정 된 사항들은 이후 개발을 고려해 develop 브랜치에도 똑같이 적용되어야 하므로 main과 병합 후 develop과도 병합 필요

### github-flow
- git-flow의 개선을 위해 나온 추가전략
- 자동화 개념이 들어가 있는 것이 가장 큰 특징. 일부를 수동으로 진행할 수 있다
- main(master)에 대한 규칙만 명확하게 한다면 나머지 다른 브랜치는 크게 관여하지 않는다
- hotfix나 feature를 구분하지 않으나 우선순위를 다르게 적용하는 방식
- 수시로 배포가 일어나기 때문에 pull request로 실수를 방지하는 것이 좋다

장점
1. 흐름이 비교적 단순 
2. 역할도 그만큼 단순
3. CI(개발자를 위한 자동화 프로세스인 지속적인 통합, Continuous Integration)와 배포가 자동화되어있는 프로젝트에 유용하게 적용

단점
1. 각 단계가 명확히 구분되지 않을 수 있음
2. 팀원 중 한 명이 실수할 경우 큰 문제가 생길 수 있음

#### 방식

1. main은 어떤 상황이든 배포 가능한 상황으로 유지
- main 브랜치는 항상 최신 상태를 유지해 배포
- 엄격한 역할을 사용하고, 다른 브랜치와 병합 전 충분한 테스트가 필요
- 보통 로컬에서보다 push 후 Jenkins로 테스트 후 적용

2. 새로운 개발을 위한 브랜치를 만들 때, 이름을 명확히 작성
- 기능 개발 브랜치는 항상 main브랜치에서 분기
- feature나 develop과 같은 브랜치가 따로 존재하지 않는다
- 새 기능 추가, 버그 수정을 위해 브랜치 생성 시, 브랜치 이름만으로 어떤 일을 목적으로 하는지 명확하게 제시할 것

3. 항상 원격 저장소에 자신이 하고 있는 일들을 올리고, 다른 사람들도 확인할 수 있도록 할 것
- 원격 저장소의 지속적인 업로드로 전체 팀원들이 작업이 수월하게 연결 가능하도록 만드는 것이 핵심
- 하드웨어/기타 예상 못한 문제로 작업내용이 손실되어도 원격 저장소로 이전소스를 받을 수 있어 비교적 안전함

4. 다른 사람의 피드백이나 도움 필요시 main과 병합 완료 후 pull request 생성
- pull request를 활용해 코드를 공유 후 리뷰를 받고, 수정사항 반영
- 후에 추가 수정이 없으면 main과 병합

5. main과 작업 브랜치의 병합은 계획논의와 CI가 끝나면 할 것

6. main과 병합이 발생 시 자동배포가 되도록 설정할 것(자동화)



### 깃을 통한 협업의 흐름 순서

1. 관리자가 프로젝트의 repo 생성
- 관리자의 컴퓨터에서 git flow init
- develop branch까지 생성 후 원격 저장소 연결 마무리

2. 작업자는 관리자가 만든 repo를 fork
- 작업자 자신의 원격 저장소에 repo를 생성
- fork된 원격 저장소를 주소로 프로젝트 git clone 후 컴퓨터에 생성
- 원격 저장소에 있는 branch들과 연결, 동기화가 이루어졌는지 확인 필요

3. 동기화 문제가 없을 시 작업자가 로컬에 새 브랜치를 생성해 작업 시작

4. 관리자와 작업자가 함께 원격 저장소에서 협업을 위한 작업 목록을 issue로 작성 후 계획 진행

5. 작업자는 목표한 작업을 완성 후, fork되어있던 자신의 원격 브랜치에 적용해 점검

⭐ 개발 진행상황에 맞춰 지속적으로 원격/로컬 저장소를 확인해 변경사항 적용할 것(후에 일어날 수 있는 깃 충돌을 방지)

⭐ ​관용적으로는 upstream이라는 이름으로 원격 저장소 생성, 프로젝트의 브랜치로부터 fetch merge, pull 필요 시 데이터를 받아 자신의 로컬, fork된 repo에 함께 연결해 변경사항 적용

6. 작업자는 자신의 원격 브랜치에 적용된 것들이 문제가 없다면, 실제 프로젝트의 원격 저장소인 develop 브랜치쪽으로 merge 요청
- 작업자가 목표로 했던 것과 실제 해결한 작업 목록, 진행 사항 등을 알려주는 내용 등 작성
- 이전에 작성했던 issue의 번호를 `#`를 사용해 연결하고 보내기

7. 관리자는 작업자의 pull request를 확인해 코드리뷰 (comment, approve, reject), 개선사항 등을 전달

8. 작업자는 관리자의 요청사항에 맞게 기능 개선, 버그 수정 등을 마치고 관리자에게 다시 승인 요청
- 주기적으로 원격저장소의 merge된 사항, 변경된 부분을 확인하여 pull할 것

9. 관리자는 작업자가 개선된 사항들이 문제가 없다고 판단 시 요청을 승인, 이후 실제 프로젝트의 원격 저장소와 merge를 진행